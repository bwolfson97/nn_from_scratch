# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Variable']

# Cell
from typing import Union

# Cell
class Variable:
    def __init__(self, value: float, local_grads: list[tuple["Variable", float]]=None) -> None:
        self.value = value
        self.grad = 0.
        self._local_grads = [] if local_grads is None else local_grads

    def backwards(self):
        self.grad = 1.
        def compute_grads(var):
            """Apply 1 step of the chain rule, populating `var`'s children variables with their full gradient."""
            for child_var, local_grad in var._local_grads:
                # Apply the chain rule
                child_var.grad += var.grad * local_grad  # Add in case this var is used in other paths
                compute_grads(child_var)
        compute_grads(self)

    def __add__(self, other):
        if isinstance(other, Variable):
            return Variable(self.value + other.value, [(self, 1), (other, 1)])
        else:  # other is constant
            return Variable(self.value + other, [(self, 1)])

    def __mul__(self, other):
        if isinstance(other, Variable):
            return Variable(self.value * other.value, [(self, other.value), (other, self.value)])
        else:  # other is constant
            return Variable(self.value * other, [(self, other)])

    def __neg__(self):
        return Variable(-self.value, [(self, -1)])

    def __sub__(self, other): return self + (-other)

    def __truediv__(self, other):
        if isinstance(other, Variable):
            return Variable(self.value / other.value, [(self, 1 / other.value), (other, -self.value / other.value**2)])
        else:
            return Variable(self.value / other, [(self, 1 / other)])

    def __pow__(self, power: float):
        return Variable(self.value ** power, [(self, power * self.value ** (power - 1))])

    def __eq__(self, other) -> bool:
        if isinstance(other, Variable): return self.value == other.value
        else:                           return self.value == other

    def __repr__(self) -> str:
        values = dict(value=self.value, grad=self.grad, _local_grads=self._local_grads)
        return f"Variable: {values}"

    def __str__(self) -> str: return repr(self)